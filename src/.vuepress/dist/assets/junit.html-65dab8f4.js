import{ab as i,M as o,N as r,L as a,$ as e,W as t,ac as n,a1 as l}from"./framework-b36c0771.js";const p={},u=a("iframe",{width:"100%",height:"400",src:"https://www.youtube.com/embed/LJcpJELfjcc",title:"YouTube video player",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture",allowfullscreen:""},null,-1),c=a("p",null,"Vienetų testai (angl. Unit tests) - tai programinės įrangos testai, kuriuos programuotojai parašė naudodamiesi programavimo kalba ir jie turėtų būti parašyti izoliuotiems komponentams ir taip pat suteikti galimybę juos pakartotinai įvykdyti. Unit testai yra automatizuoti programų testai, tikrinantys kodo vienetus atskirai vieną nuo kito. Kiekvienas kodo vienetas (t.y. funkcija, klasė, metodas) turi savo testą ar kelis testus.",-1),d=a("p",null,[a("strong",null,"Testavimo nauda."),e(" E. W. Dijkstra yra pasakęs, kad testai gali įrodyti programos klaidingumą, bet negali įrodyti jos teisingumo. Ar tai reiškia, kad testų rašyti neapsimoka? Ne. Testai padeda įsitikinti, kad keisdami programą jos netyčia nesugadinome. Testų rašymas dažnai sugauna žioplas klaidas, kurias padaro pavargęs programuotojas. Iš kitos pusės reikia jausti saiką -- jei funkcija tokia triviali, kad joje tikrai klaidų būti negali, nėra prasmės rašyti jai testo -- geriau tą sutaupytą laiką sunaudoti rašant testą sudėtingai funkcijai.")],-1),m={href:"https://vma-test.viko.lt/mod/glossary/showentry.php?eid=32&displayformat=dictionary",title:"Terminų ir santrumpų žodynas: Java",target:"_blank",rel:"noopener noreferrer"},k=a("figure",null,[a("img",{src:"https://lh6.googleusercontent.com/xTicpsRpwcIe08DIsnQboUy94UI5GEQygzdQgN3tQXsHoYrDMs_PlLNykFxL_Z7pMWFcjaQffBAGyRTgMY5uQH65ykzObuctH90mLoo_hPIkImqgZ_W5sW_1CKv1MMEkvIwoBsCCOig",alt:"",tabindex:"0",loading:"lazy"}),a("figcaption")],-1),h={href:"https://junit.org/junit5/",target:"_blank",rel:"noopener noreferrer"},g=n(`<p>Rašant Unit testus verta atsižvelgti į keletą rekomendacijų:</p><ul><li>Aprašant Unit testą pasirinkti naming convention metodams.</li><li>Negalima naudoti loginių sakinių pvz: IF, SWITCH ar kt.</li><li>VIENAS TESTAS VIENAS ASSERT METODAS. (Jeigu panašūs pavadinimai pridėti skaičių 1..n prie metodo pavadinimo, bet vistiek kurti atskirą metodą, kad lengviau būtų surasti, kur įvyko klaida).</li><li>Daugelis IDE leidžia paleisti testą su CODE COVERAGE (rodo kiek procentaliai testų yra padengusių production kodą) jeigu yra 90-100% kas yra labai gerai, bet dažniausiai tai yra keistas reiškinys, kadangi aklai pasitikėti negalime, reikia papildomo etapo TEST REVIEW, kuriam galima naudoti specialius įrankius papildomam testavimui.</li><li>Jeigu yra kuriamas objekto instance daugiau nei vieną kartą, kuris bus naudojamas keliuose skirtinguose assertuose tada galime įkelti į init(){...} metodą.</li><li>Jeigu turite kokį nors pagalbinį objektą jį privalote pavadinti pvz:</li><li>FakeStudentClass ar kokį nors kitą, kad būtų aiškų, kad ši klasė yra skirta testavimui.</li><li>PASTABA! NAUDOJANT TDD -&gt; TESTO LOGIKA NEGALI SUTAPTI SU PRODUCTION KODU.</li></ul><p>Taip pat reikėtų atkreipti dėmesį rašant testus ir naudojant assert metodus naudoti tik aiškius skaičius t.y. jeigu reikia aprašyti atskirą kintamąjį kaip konstantą su kuo aiškesniu pavadinimu nusaknačių ką tas skaičius reiškia.</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token number">1003</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">calc<span class="token punctuation">.</span></span>Parse</span><span class="token punctuation">(</span><span class="token string">&quot;-1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1003 -&gt; &quot;magiškasis&quot; skaičius pakeisti į konstanta būtų geriausias būdas.</span>

<span class="token keyword">int</span> parseInt <span class="token operator">=</span> <span class="token class-name"><span class="token namespace">calc<span class="token punctuation">.</span></span>Parse</span><span class="token punctuation">(</span><span class="token constant">NEGATIVE_ILLEGAL_VALUE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token constant">NEGATIVE_PARSE_RETURN_CODE</span><span class="token punctuation">,</span> parseInt<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Atlikus pakeitimą iš skaičiaus 1003 jį aprašius kaip konstantą NEGATIVE_PARSE_RETURN_CODE šis tekstas nusako ką reiškia šis skaičius ir įvykus klaidai arba atliekant testus ir testui nepraėjus (angl. failed) daug paprasčiau bus surandama klaida ir ištaisoma nesvarstant kas čia per magiškas skaičius.</p><p>4.2. Testavimo karkasai programinei įrangai kurti</p><p>Viena iš įdomesnių metodikų tai naudojant testų biblioteką rašyti programas. Šis būdas yra vadinamas &quot;Test-Driven Development&quot;, kai pradžioje yra rašomi testai, o tik tada programinis kodas, priklausomai kokio rezultato tikimės.</p><p><strong>What is Test Driven Development (TDD)?</strong></p><p>TDD cycle defines:</p><ol><li>Write a test</li><li>Make it run.</li><li>Change code to make it right i.e. Refactor.</li><li>Repeat process.</li></ol><p>Some clarifications about TDD:</p><ul><li>TDD is neither about &quot;Testing&quot; nor about &quot;Design&quot;.</li><li>TDD does not mean &quot;write some of the tests, then build a system that passes the tests.</li><li>TDD does not mean &quot;do lots of Testing.&quot;</li></ul><p>Test-Driven development is a process of developing and running automated test before actual development of the application. Hence, TDD sometimes also called as Test First Development.</p>`,13),v={href:"https://vma-test.viko.lt/mod/glossary/showentry.php?eid=32&displayformat=dictionary",title:"Terminų ir santrumpų žodynas: Java",target:"_blank",rel:"noopener noreferrer"},b={href:"https://vma-test.viko.lt/mod/glossary/showentry.php?eid=32&displayformat=dictionary",title:"Terminų ir santrumpų žodynas: Java",target:"_blank",rel:"noopener noreferrer"},f=n(`<p>Place test classes in the same package as implementation Benefits: helps finding tests.<br> Knowing that tests are in the same package as the code they test helps finding them faster. For example, examples in this article are in the package com.wordpress.technologyconversations.tddbestpractices. As stated in the previous practice, even though packages are the same, classes are in the separate source directories.</p><figure><img src="https://lh4.googleusercontent.com/gL1la2LbaEr5Ia5Y4HFXjawAnaqwxMpi-ZCE7wGMZldNHY_JVSTRoEZFs7-Dzvnkszsk4YnPLT2t5IlYufhYyv5LEfdT0tEy2mwKiv2hZJSv133y-MBuFiqCqL-qsbeFFUOf45xsHX4" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>Name test classes in a similar fashion as classes they test</p><p>Benefits: helps finding tests.<br> One commonly used practice is to name tests the same as implementation classes with suffix Test. If, for example, implementation class is StringCalculator, test class should be StringCalculatorTest.</p><p>To help locate methods that are tested, test classes can be split. For example, if StringCalculator has methods add and remove, there can be test classes StringCalculatorAddTest and StringCalculatorRemoveTest.</p><figure><img src="https://lh4.googleusercontent.com/9XwTL0gXoZDT2WxogMQNHaMpjueA2wbXUR9bQgNpMK99lRAiyiGsTzaErgATVphY1qD2ZBkyC8U7IJyiXxhlIuFHz3RXCtD8_uom5lRg0HjAgn8a-TuzMKI6q-kZ1tOLKUJIW7_6NPM" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>Use descriptive names for test methods</p><p>There are many different ways to name test methods. Our prefered method is to name them using the Given/When/Then syntax used in BDD scenarios. Given describes (pre)conditions, When describes actions and Then describes the expected outcome. If some test does not have preconditions (usually set using @Before and @BeforeClass annotations), Given can be skipped.</p><p>An example of BDD format for naming test methods would be:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Test</span>

<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">whenSemicolonDelimiterIsSpecifiedThenItIsUsedToSeparateNumbers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

  <span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token operator">+</span><span class="token number">6</span><span class="token operator">+</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token class-name">StringCalculator</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;//;n3;6;15&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Do NOT rely only on comments to provide information about test objective</p><p>Comments do not appear when tests are executed from your favorite IDE nor do they appear in reports generated by CI or build tools. In the example screenshot, both failed tests have the same code inside. The only difference is in the name of the method. Test1 does not give much info regarding the failure. Method name sudeti_jeiguSkaiciusYraTeigiamas_grazintiDviejuSkaiciuSuma is much more descriptive and provides information even without going deeper into the log or the test code.</p><figure><img src="https://lh3.googleusercontent.com/kqaRzl-MmRSmTSOmURCWMm1ckl2drbvIYeDbc5xje7na66ZOp8Cs62F8GaBL0KK7ez4tf5gWw0jiQhEZBz9eWDl2gKCRv8-NjsHo3WNq7QC55tjnRDFlQJDPstIPgIypC7U6muRbvI0" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>Kadangi automatiniai testai gali būti taikomi ir ne tik programinei įrangai kurti bet ir pavyzdžiui patikrinti ar korektiškai veikia sukurta Web svetainė. Vienas iš populiariausių bibliotekų yra Selenium. Kadangi TDD arba BDD pavadinimų reikalavimai yra tokie, kad aprašomo testo pavadinimas yra labai ilgas. Kad išvengti ilgų rašliavų papildomai yra sukurtas scenarijų rašymui skirtas karkasas padedantis surašyti žingsnius, kuris atitinka 1 metodą su konkrečiu aprašu ir yra automatiškai sugeneruojamas belieka aprašyti logiką. Toliau bus pateiktas pavyzdys, kuriame yra naudojama 3 bibliotekos/karkasai.</p><p>Selenium - pajungti testinę interneto naršyklę, kurioje naudosime šį automatinį testą imituodami įvairius mygtuko paspaudimus ir teksto įvedimus programiškai. Cucumber yra kombinuojamas su Gherkin ir skirtas rašyti BDD scenarijams. Gherkin karkasas leidžia aprašyti scenarijų žmogus, kuris neturi programavimo žinių taip pat gali suformuoti šį dokumentą ir pagal tai programuotojas įgyvendins tik tai kas yra parašyta.</p><p>Failo pavadinimas naudojant Gherkin: <strong>cucumber.feature</strong>;</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Feature</span><span class="token operator">:</span> search <span class="token class-name">Wikipedia</span>

<span class="token class-name">Scenario</span><span class="token operator">:</span> direct search article

<span class="token class-name">Given</span> <span class="token class-name">Enter</span> search term &#39;<span class="token class-name">Cucumber</span>&#39;

<span class="token class-name">When</span> <span class="token class-name">Do</span> search

<span class="token class-name">Then</span> <span class="token class-name">Single</span> result is shown <span class="token keyword">for</span> &#39;<span class="token class-name">Cucumber</span>&#39;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Be Gherkin karkaso privalėtumėme laikytis testo metodų pavadinimo sudarymo:</p><p>MethodName_StateUnderTest_ExpectedBehavior: There are arguments against this strategy that if method names change as part of code refactoring than test name like this should also change or it becomes difficult to comprehend at a later stage. Following are some of the example:</p><ul><li>isAdult_AgeLessThan18_False</li><li>withdrawMoney_InvalidAccount_ExceptionThrown</li><li>admitStudent_MissingMandatoryFields_FailToAdmit</li></ul><p>MethodName_ExpectedBehavior_StateUnderTest: Slightly tweeked from above, but a section of developers also recommend using this naming technique. This technique also has disadvantage that if method names get changed, it becomes difficult to comprehend at a later stage. Following is how tests in first example would read like if named using this technique:</p><ul><li>isAdult_False_AgeLessThan18</li><li>withdrawMoney_ThrowsException_IfAccountIsInvalid</li><li>admitStudent_FailToAdmit_IfMandatoryFieldsAreMissing</li></ul><p>test[Feature being tested]: This one makes it easy to read the test as the feature to be tested is written as part of test name. Although, there are arguments that the “test” prefix is redundant. However, some sections of developer love to use this technique. Following is how the above tests would read like if named using this technique:</p><ul><li>testIsNotAnAdultIfAgeLessThan18</li><li>testFailToWithdrawMoneyIfAccountIsInvalid</li><li>testStudentIsNotAdmittedIfMandatoryFieldsAreMissing</li></ul><p>Feature to be tested: Many suggests that it is better to simply write the feature to be tested because one is anyway using annotations to identify method as test methods. It is also recommended for the reason that it makes unit tests as alternate form of documentation and avoid code smells. Following is how tests in first example would read like if named using this technique:</p><ul><li>IsNotAnAdultIfAgeLessThan18</li><li>FailToWithdrawMoneyIfAccountIsInvalid</li><li>StudentIsNotAdmittedIfMandatoryFieldsAreMissing</li></ul><p>Should_ExpectedBehavior_When_StateUnderTest: This technique is also used by many as it makes it easy to read the tests. Following is how tests in first example would read like if named using this technique:</p><ul><li>Should_ThrowException_When_AgeLessThan18</li><li>Should_FailToWithdrawMoney_ForInvalidAccount</li><li>Should_FailToAdmit_IfMandatoryFieldsAreMissin</li></ul><p>When_StateUnderTest_Expect_ExpectedBehavior: Following is how tests in first example would read like if named using this technique:</p><ul><li>When_AgeLessThan18_Expect_isAdultAsFalse</li><li>When_InvalidAccount_Expect_WithdrawMoneyToFail</li><li>When_MandatoryFieldsAreMissing_Expect_StudentAdmissionToFail</li></ul><p>Given_Preconditions_When_StateUnderTest_Then_ExpectedBehavior: This approach is based on naming convention developed as part of Behavior-Driven Development (BDD). The idea is to break down the tests into three part such that one could come up with preconditions, state under test and expected behavior to be written in above format. Following is how tests in first example would read like if named using this technique:</p><ul><li>Given_UserIsAuthenticated_When_InvalidAccountNumberIsUsedToWithdrawMoney_Then_TransactionsWillFail</li></ul><p>Prieš rašant programinį kodą rašant automatinius testus reikėtų papildomai atsisiųsti draiverį, priklausomai su kuria naršykle dirbsite. Testo klasėje nurodyti draiverį, kurį naudosite:</p><p>Driveriai turi atitikti naršyklės versiją, pvz: ChromeDriver V61 - reikia 2.29v.</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Before</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

<span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token string">&quot;webdriver.chrome.driver&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;chromedriver.exe&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  driver <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ChromeDriver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  driver<span class="token punctuation">.</span><span class="token function">navigate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">(</span><span class="token string">&quot;http://en.wikipedia.org&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,35),y={href:"https://www.browserstack.com/guide/junit-and-automation-testing",target:"_blank",rel:"noopener noreferrer"},_={href:"https://www.tutorialspoint.com/cucumber/cucumber_annotations.htm",target:"_blank",rel:"noopener noreferrer"},T={href:"http://automationrhapsody.com/introduction-to-cucumber-and-bdd-with-examples/",target:"_blank",rel:"noopener noreferrer"},w={href:"https://github.com/mozilla/geckodriver/releases",target:"_blank",rel:"noopener noreferrer"},j={href:"https://sites.google.com/a/chromium.org/chromedriver/downloads",target:"_blank",rel:"noopener noreferrer"};function I(A,D){const s=l("ExternalLinkIcon");return o(),r("div",null,[u,c,d,a("p",null,[e("Programavimo kalboje "),a("a",m,[e("Java"),t(s)]),e(" yra numatytas karkasas rašyti vienetų testus naudojan JUnit biblioteką. Šis karkasas yra sukurtas šių autorių: Erich Gamma ir Kent Beck. Šis Unit testų karkasas yra viešai prieinamas visiems. Todėl kitos programavimo kalbos turi savo asmeniškas Unit test bibliotekas naudojančios šių autorių sukurtą programinį kodo branduolį savo realizacijai. Papildomai galima peržiūrėti paveikslėlį, kuriame matome įvairių kalbų Unit testų bibliotekas.")]),k,a("p",null,[e("Plačiau apie JUNIT 5 ar senesnę versiją rasite oficialią dokumentaciją: "),a("a",h,[e("https://junit.org/junit5/"),t(s)]),e(".")]),g,a("p",null,[e("Separate the implementation from the test code Benefits: avoids accidentally packaging tests together with production binaries; many build tools expect tests to be in a certain source directory. Common practice is to have at least two source directories. Implementation code should be located in src/main/"),a("a",v,[e("java"),t(s)]),e(" and test code in src/test/"),a("a",b,[e("java"),t(s)]),e(". In bigger projects number of source directories can increase but the separation between implementation and tests should remain.")]),f,a("p",null,[a("a",y,[e("https://www.browserstack.com/guide/junit-and-automation-testing"),t(s)])]),a("p",null,[e("Pavyzdys Nr 1: "),a("a",_,[e("https://www.tutorialspoint.com/cucumber/cucumber_annotations.htm"),t(s)]),e(";")]),a("p",null,[e("Pavyzdys Nr 2: "),a("a",T,[e("http://automationrhapsody.com/introduction-to-cucumber-and-bdd-with-examples/"),t(s)]),e(";")]),a("p",null,[e("Web driver FireFox:"),a("a",w,[e("https://github.com/mozilla/geckodriver/releases"),t(s)])]),a("p",null,[e("Web driver ChromeDriver: "),a("a",j,[e("https://sites.google.com/a/chromium.org/chromedriver/downloads"),t(s)])])])}const x=i(p,[["render",I],["__file","junit.html.vue"]]);export{x as default};
